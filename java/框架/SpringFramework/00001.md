### Spring工作的大致流程
---

启动、扫描、创建bean(默认非懒加载的单利bean)

扫描会去判断传进来的配置类有没有CompoentScan的注解，从而拿到扫描路径，通过类加载器ClassLoader.getResource(path)拿到目录，通过类加载器ClassLoader.loadClass()在拿到class,再去判断当前累有没有Component和lazy、scope注解，当然也可以通过Component拿到他的value及名字。。。。但是考虑一下两种情况：第一，你可以通过Application.getBean（name）来得到一个bean,是不是需要个map来存储你这个名字对应的类。第二，如果你可以快速得到对应的这个类，是不是每次getBean的时候都去解析这个Bean是不是单例的是原型的，但是Spring并不是这样做的，下面就可以了解一下BeanDefinition这个概念了，可以通过给BeanDefinition定义scope、isLazy 、beanClass。首先要区分BeanDefinition和Bean对象  BeanDefinition是bean对象的定义，先有beanDefiniton后又Bean对象。 之后就可以在BeanDefinitonMap<name,BeanDefinition>中判断bean有没有定义，拿到beanDefinition，判断scope是不是单例的并且不是懒加载的去单例池中得到，如果单例池中没有则去CreateBean()，如果是prototype，每次都去创建CreateBean()。然后在getBean()方法里面去判断是不是lazy.

然后如何实现Autowired呢？首先我们在CreateBean的时候先去实例化对象，然后给这个对象属性赋值即填充属性？通过反射拿的所有的属性（.getDeclaredFields()）并且判断他是不是有加Autowired注解（declaredField.isAnnotationPresent(Autowired.class)）就可以属性赋值（declaredField.setAccessible(True);declaredField.set(instance,bean)）

但是又要考虑到是byName还是ByType的问题才能GetBean,Autowired是先ByType得到在再ByName拿到Bean,name是唯一的 type可能有很多个，为啥要先ByType呢？可以这么想 如果byName拿到的bean并不是你想要的Type属性呢？这就没意义了

当然有几个接口 也是很重要的比如BeanNameAware 基于回调setBeanname; InitializingBean基于回调检查bean的属性。这些也是都放生bean的生命周期中


---
*[👈 0000 Java目录](../../0000Java目录.md)*

*[415 出品，必属精品](../../../note.md)*