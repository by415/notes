### Spring中的依赖注入(下)
---
####自己注入自己
  定义一个类，类里面提供了一个构造方法，用来设置name属性
  ```java
public class UserService { 

    private String name;

    public UserService(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    @Autowired
    private UserService userService;


    public void test() {
        System.out.println(userService.getName());
    }
}
```
  然后针对UserService定义两个Bean:
  ```java
   @Bean
      public UserService userService1() {
          return new UserService("userService1");
      }
  
      @Bean
      public UserService userService() {
          return new UserService("userService");
      }
```
  按照正常逻辑来说，对于注入点：
  ```java
  @Autowired
  private UserService userService;
```
  会先根据UserService类型去找Bean，找到两个，然后根据属性名字“userService”找到一个beanName为userService的Bean，但是我们直接运行Spring，会发现注入的是“userService1”的那个Bean。
  这是因为Spring中进行了控制，尽量“自己不注入自己”。
####Resource注解底层原理

  ![image-Resource](../../demo/picture/@Resource注解底层工作原理.png)

####总结
对于@Resource：
  1. 如果@Resource注解中指定了name属性，那么则只会根据name属性的值去找bean，如果找不到则报错
  2. 如果@Resource注解没有指定name属性，那么会先判断当前注入点名字（属性名字或方法参数名字）是不是存在Bean，如果存在，则直接根据注入点名字取获取bean，如果不存在，则会走@Autowired注解的逻辑，会根据注入点类型去找Bean

####Bean的销毁过程
  1. 容器关闭
  2. 发布ContextClosedEvent事件
  3. 调用LifecycleProcessor的onClose方法
  4. 销毁单例Bean
  1. 找出所有DisposableBean(实现了DisposableBean接口的Bean)
  2. 遍历每个DisposableBean
  3. 找出依赖了当前DisposableBean的其他Bean，将这些Bean从单例池中移除掉
  4. 调用DisposableBean的destroy()方法
  5. 找到当前DisposableBean所包含的inner beans，将这些Bean从单例池中移除掉 (inner bean参考https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-inner-beans)
  这里涉及到一个设计模式：适配器模式
  在销毁时，Spring会找出实现了DisposableBean接口的Bean。
---
*[👈 0000 Java目录](../../0000Java目录.md)*

*[415 出品，必属精品](../../../note.md)*